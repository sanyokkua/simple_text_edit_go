// Code generated by mockery v2.20.0. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	"github.com/wailsapp/wails/v2/pkg/runtime"
	types "simple_text_editor/core/v3/types"
)

// ITypeManager is an autogenerated mock type for the ITypeManager type
type ITypeManager struct {
	mock.Mock
}

// BuildFileTypeMappingExtToExt provides a mock function with given fields: fileTypeKey
func (_m *ITypeManager) BuildFileTypeMappingExtToExt(fileTypeKey types.FileTypeKey) ([]types.KeyValuePairStruct, error) {
	ret := _m.Called(fileTypeKey)

	var r0 []types.KeyValuePairStruct
	var r1 error
	if rf, ok := ret.Get(0).(func(types.FileTypeKey) ([]types.KeyValuePairStruct, error)); ok {
		return rf(fileTypeKey)
	}
	if rf, ok := ret.Get(0).(func(types.FileTypeKey) []types.KeyValuePairStruct); ok {
		r0 = rf(fileTypeKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.KeyValuePairStruct)
		}
	}

	if rf, ok := ret.Get(1).(func(types.FileTypeKey) error); ok {
		r1 = rf(fileTypeKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildFileTypeMappingKeyToName provides a mock function with given fields:
func (_m *ITypeManager) BuildFileTypeMappingKeyToName() ([]types.KeyValuePairStruct, error) {
	ret := _m.Called()

	var r0 []types.KeyValuePairStruct
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]types.KeyValuePairStruct, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []types.KeyValuePairStruct); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.KeyValuePairStruct)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExtensionsForType provides a mock function with given fields: key
func (_m *ITypeManager) GetExtensionsForType(key types.FileTypeKey) ([]types.FileTypeExtension, error) {
	ret := _m.Called(key)

	var r0 []types.FileTypeExtension
	var r1 error
	if rf, ok := ret.Get(0).(func(types.FileTypeKey) ([]types.FileTypeExtension, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(types.FileTypeKey) []types.FileTypeExtension); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.FileTypeExtension)
		}
	}

	if rf, ok := ret.Get(1).(func(types.FileTypeKey) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSupportedFileFilters provides a mock function with given fields:
func (_m *ITypeManager) GetSupportedFileFilters() []runtime.FileFilter {
	ret := _m.Called()

	var r0 []runtime.FileFilter
	if rf, ok := ret.Get(0).(func() []runtime.FileFilter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]runtime.FileFilter)
		}
	}

	return r0
}

// GetTypeKeyByExtension provides a mock function with given fields: extension
func (_m *ITypeManager) GetTypeKeyByExtension(extension types.FileTypeExtension) (types.FileTypeKey, error) {
	ret := _m.Called(extension)

	var r0 types.FileTypeKey
	var r1 error
	if rf, ok := ret.Get(0).(func(types.FileTypeExtension) (types.FileTypeKey, error)); ok {
		return rf(extension)
	}
	if rf, ok := ret.Get(0).(func(types.FileTypeExtension) types.FileTypeKey); ok {
		r0 = rf(extension)
	} else {
		r0 = ret.Get(0).(types.FileTypeKey)
	}

	if rf, ok := ret.Get(1).(func(types.FileTypeExtension) error); ok {
		r1 = rf(extension)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTypeStructByExt provides a mock function with given fields: extension
func (_m *ITypeManager) GetTypeStructByExt(extension types.FileTypeExtension) (*types.FileTypesJsonStruct, error) {
	ret := _m.Called(extension)

	var r0 *types.FileTypesJsonStruct
	var r1 error
	if rf, ok := ret.Get(0).(func(types.FileTypeExtension) (*types.FileTypesJsonStruct, error)); ok {
		return rf(extension)
	}
	if rf, ok := ret.Get(0).(func(types.FileTypeExtension) *types.FileTypesJsonStruct); ok {
		r0 = rf(extension)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.FileTypesJsonStruct)
		}
	}

	if rf, ok := ret.Get(1).(func(types.FileTypeExtension) error); ok {
		r1 = rf(extension)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTypeStructByKey provides a mock function with given fields: key
func (_m *ITypeManager) GetTypeStructByKey(key types.FileTypeKey) (*types.FileTypesJsonStruct, error) {
	ret := _m.Called(key)

	var r0 *types.FileTypesJsonStruct
	var r1 error
	if rf, ok := ret.Get(0).(func(types.FileTypeKey) (*types.FileTypesJsonStruct, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(types.FileTypeKey) *types.FileTypesJsonStruct); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.FileTypesJsonStruct)
		}
	}

	if rf, ok := ret.Get(1).(func(types.FileTypeKey) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewITypeManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewITypeManager creates a new instance of ITypeManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewITypeManager(t mockConstructorTestingTNewITypeManager) *ITypeManager {
	mock := &ITypeManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
